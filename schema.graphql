# Some items included in this schema come from and are inspired by the Messari Generic Schema

enum MarketStatus {
  ACTIVE
  FILLED
  FILLED_PARTIAL
  CANCELLED
  CANCELLED_PARTIAL
  EXPIRED
}

enum PlotSource {
  SOW
  HARVEST
  TRANSFER
}

type Beanstalk @entity {
  " Smart contract address of the protocol's main contract (Factory, Registry, etc) "
  id: ID!

  " Name of the protocol, including version. e.g. Uniswap v3 "
  name: String!

  " Slug of protocol, including version. e.g. uniswap-v3 "
  slug: String!

  " Version of the subgraph schema, in SemVer format (e.g. 1.0.0) "
  schemaVersion: String!

  " Version of the subgraph implementation, in SemVer format (e.g. 1.0.0) "
  subgraphVersion: String!

  " Version of the methodology used to compute metrics, loosely based on SemVer format (e.g. 1.0.0) "
  methodologyVersion: String!

  " Timestamp of the latest DiamondCut call "
  lastUpgrade: BigInt!
  
  " Season specific data "
  seasons: [Season!]! @derivedFrom(field: "beanstalk")
  
  " Silo level data "
  silo: Silo! @derivedFrom(field: "beanstalk")

  " Field level data "
  field: Field! @derivedFrom(field: "beanstalk")

  " Last season called "
  lastSeason: Int!

  " Array of the addresses for all active farmers in the silo "
  activeFarmers: [String!]!

  " Array of the addresses for all farmers that had silo transfers and need stalk/seeds/roots updated "
  farmersToUpdate: [String!]!
}

# An entity that holds season level data
type Season @entity {
  " Season Number" 
  id: ID!
  
  " Beanstalk Contract Address "
  beanstalk: Beanstalk!

  " Season number in Int form for sorting "
  season: Int!

  " Block timestamp when sunrise was called "
  createdAt: BigInt!
  
  " Price of BEAN during sunrise "
  price: BigDecimal!

  " Total Bean supply "
  beans: BigInt!

  " Bean Market Cap "
  marketCap: BigDecimal!

  " Time weighted deltaB "
  deltaB: BigInt!

  " Change in Bean supply "
  deltaBeans: BigInt!

  " Amount of Beans minted during sunrise "
  rewardBeans: BigInt!

  " Amount of Beans paid to sunrise caller "
  incentiveBeans: BigInt!

  " New harvestable index for the season "
  harvestableIndex: BigInt!
}

type Silo @entity {
  "Address for the farmer or Beanstalk"
  id: ID!
  "Beanstalk diamond address"
  beanstalk: Beanstalk!
  "Farmer address if applicable"
  farmer: Farmer
  "Tokens whitelisted for deposit within the silo"
  whitelistedTokens: [String!]!
  "Link to all silo assets currently associated with this silo"
  assets: [SiloAsset!]! @derivedFrom(field: "silo")
  "Current BDV of all deposited assets"
  depositedBDV: BigInt!
  "Current stalk balance"
  stalk: BigInt!
  "Current plantable stalk for bean seigniorage not yet claimed"
  plantableStalk: BigInt!
  "Current seeds balance"
  seeds: BigInt!
  "Current roots balance"
  roots: BigInt!
  "Cumulative total for bean mints sent to the silo"
  beanMints: BigInt!
  "Current number of active farmers deposited in the silo"
  activeFarmers: Int!
  "Link to hourly snapshot data"
  hourlySnapshots: [SiloHourlySnapshot!]! @derivedFrom(field: "silo")
  "Link to daily snapshot data"
  dailySnapshots: [SiloDailySnapshot!]! @derivedFrom(field: "silo")
}

type SiloHourlySnapshot @entity {
  "ID of silo-Unix Hour Timestamp"
  id: ID!
  "Season for the snapshot"
  season: Int!
  "Silo associated with the snapshot"
  silo: Silo!
  "Point in time current BDV of all deposited assets"
  depositedBDV: BigInt!
  "Point in time current stalk balance"
  stalk: BigInt!
  "Point in time current plantable stalk for bean seigniorage not yet claimed"
  plantableStalk: BigInt!
  "Point in time current seeds balance"
  seeds: BigInt!
  "Point in time current roots balance"
  roots: BigInt!
  "Point in time cumulative total for bean mints sent to the silo"
  beanMints: BigInt!
  "Point in time current number of active farmers deposited in the silo"
  activeFarmers: Int!
  "Point in time delta BDV of all deposited assets"
  deltaDepositedBDV: BigInt!
  "Point in time delta stalk balance"
  deltaStalk: BigInt!
  "Point in time current plantable stalk for bean seigniorage not yet claimed"
  deltaPlantableStalk: BigInt!
  "Point in time delta seeds balance"
  deltaSeeds: BigInt!
  "Point in time delta roots balance"
  deltaRoots: BigInt!
  "Point in time delta total for bean mints sent to the silo"
  deltaBeanMints: BigInt!
  "Point in time delta number of active farmers deposited in the silo"
  deltaActiveFarmers: Int!
  "Timestamp of initial snapshot creation"
  createdAt: BigInt!
  "Timestamp of last entity update"
  updatedAt: BigInt!
}

type SiloDailySnapshot @entity {
  "ID of silo-Unix Hour Timestamp"
  id: ID!
  "Last season for the snapshot"
  season: Int!
  "Silo associated with the snapshot"
  silo: Silo!
  "Point in time current BDV of all deposited assets"
  depositedBDV: BigInt!
  "Point in time current stalk balance"
  stalk: BigInt!
  "Point in time current plantable stalk for bean seigniorage not yet claimed"
  plantableStalk: BigInt!
  "Point in time current seeds balance"
  seeds: BigInt!
  "Point in time current roots balance"
  roots: BigInt!
  "Point in time cumulative total for bean mints sent to the silo"
  beanMints: BigInt!
  "Point in time current number of active farmers deposited in the silo"
  activeFarmers: Int!
  "Point in time delta BDV of all deposited assets"
  deltaDepositedBDV: BigInt!
  "Point in time delta stalk balance"
  deltaStalk: BigInt!
  "Point in time current plantable stalk for bean seigniorage not yet claimed"
  deltaPlantableStalk: BigInt!
  "Point in time delta seeds balance"
  deltaSeeds: BigInt!
  "Point in time delta roots balance"
  deltaRoots: BigInt!
  "Point in time delta total for bean mints sent to the silo"
  deltaBeanMints: BigInt!
  "Point in time delta number of active farmers deposited in the silo"
  deltaActiveFarmers: Int!
  "Timestamp of initial snapshot creation"
  createdAt: BigInt!
  "Timestamp of last entity update"
  updatedAt: BigInt!
}

type SiloAsset @entity {
  "Silo ID - Asset Token Address"
  id: ID!
  "Silo for this asset"
  silo: Silo!
  "Token address for this asset"
  token: String!
  "Current BDV of deposits"
  depositedBDV: BigInt!
  "Current Token amount of deposits"
  depositedAmount: BigInt!
  "Current Token amount of silo withdrawals"
  withdrawnAmount: BigInt!
  "Current internal (farm) balance of the asset"
  farmAmount: BigInt!
  "Link to hourly snapshot data"
  hourlySnapshots: [SiloAssetHourlySnapshot!]! @derivedFrom(field: "siloAsset")
  "Link to daily snapshot data"
  dailySnapshots: [SiloAssetDailySnapshot!]! @derivedFrom(field: "siloAsset")
}

type SiloAssetHourlySnapshot @entity {
  "Silo Asset ID - Unix Timestamp"
  id: ID!
  "Season for the snapshot"
  season: Int!
  "Silo asset associated with this snapshot"
  siloAsset: SiloAsset!
  "Point in time current BDV of deposits"
  depositedBDV: BigInt!
  "Point in time current Token amount of deposits"
  depositedAmount: BigInt!
  "Point in time current Token amount of silo withdrawals"
  withdrawnAmount: BigInt!
  "Point in time current internal (farm) balance of the asset"
  farmAmount: BigInt!
  "Point in time delta BDV of deposits"
  deltaDepositedBDV: BigInt!
  "Point in time delta Token amount of deposits"
  deltaDepositedAmount: BigInt!
  "Point in time delta Token amount of silo withdrawals"
  deltaWithdrawnAmount: BigInt!
  "Point in time delta internal (farm) balance of the asset"
  deltaFarmAmount: BigInt!
  "Timestamp of initial snapshot creation"
  createdAt: BigInt!
  "Timestamp of last entity update"
  updatedAt: BigInt!
}

type SiloAssetDailySnapshot @entity {
  "Silo Asset ID - Unix Timestamp"
  id: ID!
  "Last season for the snapshot"
  season: Int!
  "Silo asset associated with this snapshot"
  siloAsset: SiloAsset!
  "Point in time current BDV of deposits"
  depositedBDV: BigInt!
  "Point in time current Token amount of deposits"
  depositedAmount: BigInt!
  "Point in time current Token amount of silo withdrawals"
  withdrawnAmount: BigInt!
  "Point in time current internal (farm) balance of the asset"
  farmAmount: BigInt!
  "Point in time delta BDV of deposits"
  deltaDepositedBDV: BigInt!
  "Point in time delta Token amount of deposits"
  deltaDepositedAmount: BigInt!
  "Point in time delta Token amount of silo withdrawals"
  deltaWithdrawnAmount: BigInt!
  "Point in time delta internal (farm) balance of the asset"
  deltaFarmAmount: BigInt!
  "Timestamp of initial snapshot creation"
  createdAt: BigInt!
  "Timestamp of last entity update"
  updatedAt: BigInt!
}

type SiloYield @entity {
  "Season of data points"
  id: ID!
  "Sortable int field for season"
  season: Int!
  "Beta used for EMA"
  beta: BigDecimal!
  "u used for EMA"
  u: Int!
  "Bean EMA for season"
  beansPerSeasonEMA: BigDecimal!
  "Bean APY for two seeds per BDV"
  twoSeedBeanAPY: BigDecimal!
  "Stalk APY for two seeds per BDV"
  twoSeedStalkAPY: BigDecimal!
  "Bean APY for four seeds per BDV"
  fourSeedBeanAPY: BigDecimal!
  "Stalk APY for four seeds per BDV"
  fourSeedStalkAPY: BigDecimal!
  "Unix timestamp of update"
  createdAt: BigInt!
}

type Field @entity {
  " Contract address for this field or farmer "
  id: ID!
  "Contract address of beanstalk"
  beanstalk: Beanstalk!
  "Farmer address if applicable"
  farmer: Farmer
  "Current season number"
  season: Int!
  "Current temperature"
  temperature: Int!
  "Rate of return: Temperature / Bean Price"
  realRateOfReturn: BigDecimal!
  "Cumulative number of unique sowers"
  numberOfSowers: Int!
  "Cumulative number of sows"
  numberOfSows: Int!
  "Cumulative total of sown beans"
  sownBeans: BigInt!
  "Array of current non-harvestable plots"
  plotIndexes: [BigInt!]!
  "Current outstanding non-harvestable pods"
  unharvestablePods: BigInt!
  "Current harvestable pods"
  harvestablePods: BigInt!
  "Cumulative harvested pods"
  harvestedPods: BigInt!
  "Current amount of soil available"
  soil: BigInt!
  "Current pod index"
  podIndex: BigInt!
  "Current pod rate: Total unharvestable pods / bean supply"
  podRate: BigDecimal!
  "Link to hourly snapshot data"
  hourlySnapshots: [FieldHourlySnapshot!]! @derivedFrom(field: "field")
  "Link to daily snapshot data"
  dailySnapshots: [FieldDailySnapshot!]! @derivedFrom(field: "field")
}

type FieldHourlySnapshot @entity {
  "Field ID - Unix Timestamp"
  id: ID!
  "Field associated with this snapshot"
  field: Field!
  "Season"
  season: Int!
  "Point in time temperature"
  temperature: Int!
  "Point in time rate of return: Temperature / Bean Price"
  realRateOfReturn: BigDecimal!
  "Point in time cumulative number of unique sowers"
  numberOfSowers: Int!
  "Point in time cumulative number of sows"
  numberOfSows: Int!
  "Point in time cumulative total of sown beans"
  sownBeans: BigInt!
  "Point in time outstanding non-harvestable pods"
  unharvestablePods: BigInt!
  "Point in time harvestable pods"
  harvestablePods: BigInt!
  "Point in time cumulative harvested pods"
  harvestedPods: BigInt!
  "Point in time amount of soil remaining"
  soil: BigInt!
  "Point in time pod index"
  podIndex: BigInt!
  "Point in time pod rate: Total unharvestable pods / bean supply"
  podRate: BigDecimal!
  "Point in time delta number of unique sowers"
  deltaNumberOfSowers: Int!
  "Point in time delta number of sows"
  deltaNumberOfSows: Int!
  "Point in time delta total of sown beans"
  deltaSownBeans: BigInt!
  "Point in time delta non-harvestable pods"
  deltaUnharvestablePods: BigInt!
  "Point in time delta harvestable pods"
  deltaHarvestablePods: BigInt!
  "Point in time delta harvested pods"
  deltaHarvestedPods: BigInt!
  "Point in time amount of soil issued"
  issuedSoil: BigInt!
  "Number of blocks between sunrise and soil being sold out"
  blocksToSoldOutSoil: BigInt!
  "Bool flag if soil sold out for the season"
  soilSoldOut: Boolean!
  "Creation Block Number"
  blockNumber: BigInt!
  "Timestamp of initial snapshot creation"
  createdAt: BigInt!
  "Timestamp of last entity update"
  updatedAt: BigInt!
}

type FieldDailySnapshot @entity {
  "Field ID - Unix Timestamp"
  id: ID!
  "Field associated with this snapshot"
  field: Field!
  "Last season in the snapshot"
  season: Int!
  "Point in time temperature"
  temperature: Int!
  "Point in time rate of return: Temperature / Bean Price"
  realRateOfReturn: BigDecimal!
  "Point in time cumulative number of unique sowers"
  numberOfSowers: Int!
  "Point in time cumulative number of sows"
  numberOfSows: Int!
  "Point in time cumulative total of sown beans"
  sownBeans: BigInt!
  "Point in time outstanding non-harvestable pods"
  unharvestablePods: BigInt!
  "Point in time harvestable pods"
  harvestablePods: BigInt!
  "Point in time delta harvested pods"
  harvestedPods: BigInt!
  "Point in time amount of soil remaining"
  soil: BigInt!
  "Point in time pod index"
  podIndex: BigInt!
  "Point in time pod rate: Total unharvestable pods / bean supply"
  podRate: BigDecimal!
  "Point in time delta number of unique sowers"
  deltaNumberOfSowers: Int!
  "Point in time delta number of sows"
  deltaNumberOfSows: Int!
  "Point in time delta total of sown beans"
  deltaSownBeans: BigInt!
  "Point in time delta non-harvestable pods"
  deltaUnharvestablePods: BigInt!
  "Point in time delta harvestable pods"
  deltaHarvestablePods: BigInt!
  "Point in time delta harvested pods"
  deltaHarvestedPods: BigInt!
  "Point in time amount of soil issued"
  issuedSoil: BigInt!
  "Timestamp of initial snapshot creation"
  createdAt: BigInt!
  "Timestamp of last entity update"
  updatedAt: BigInt!
}

# ---===== Farmer Account Entities =====---

type Farmer @entity {
  "Address for the farmer"
  id: ID!
  silo: Silo @derivedFrom(field: "farmer")
  deposits: [SiloDeposit!]! @derivedFrom(field: "farmer")
  withdraws: [SiloWithdraw!]! @derivedFrom(field: "farmer")
  field: Field @derivedFrom(field: "farmer")
  plots: [Plot!]! @derivedFrom(field: "farmer")
  listings: [PodListing!]! @derivedFrom(field: "farmer")
  orders: [PodOrder!]! @derivedFrom(field: "farmer")
  fills: [PodFill!]! @derivedFrom(field: "to")
  fertilizers: [FertilizerBalance!]! @derivedFrom(field: "farmer")
}

type SiloDeposit @entity {
  "Account - Token Address - Season"
  id: ID! 
  "Farmer address"
  farmer: Farmer!
  "Token Address"
  token: String!
  "Season of deposit"
  season: Int!
  "Current token amount deposited"
  amount: BigInt!
  "Original token amount deposited"
  depositedAmount: BigInt!
  "Token amount withdrawn"
  withdrawnAmount: BigInt!
  "Original BDV of the deposit"
  bdv: BigInt!
  "Withdrawn BDV"
  withdrawnBDV: BigInt!
  "Transaction hashes for multiple deposits in one season"
  hashes: [String!]!
  "Timestamp of first deposit"
  createdAt: BigInt!
  "Timestamp when last updated"
  updatedAt: BigInt!
}

type SiloWithdraw @entity {
  "Account - Deposit Token - Current Season"
  id: ID!
  "Farmer address"
  farmer: Farmer!
  "Token address"
  token: String!
  "Season withdrawal initiated"
  withdrawSeason: Int!
  "Season when withdrawal can be claimed"
  claimableSeason: Int!
  "Flag for if this has been claimed"
  claimed: Boolean!
  "Token amount withdrawn"
  amount: BigInt!
  "Transaction hash of withdrawal"
  hashes: [String!]!
  "Timestamp created"
  createdAt: BigInt!
}

type Plot @entity {
  "Plot index"
  id: ID! 
  "Field to which this plot belongs"
  field: Field!
  "Farmer who owns this plot"
  farmer: Farmer!
  "Transaction source for this plot"
  source: PlotSource!
  "Associated plot listing"
  listing: PodListing
  "Season when created"
  season: Int!
  "Creation transaction hash"
  creationHash: String!
  "Timestamp of creation"
  createdAt: BigInt!
  "Timestamp when updated"
  updatedAt: BigInt!
  "Plot Index"
  index: BigInt!
  "Beans used to sow, if any"
  beans: BigInt!
  "Total pods in plot"
  pods: BigInt!
  "Total pods that were sown, if any"
  sownPods: BigInt!
  "Temperature when the plot was sown"
  temperature: Int!
  "Number of pods harvestable"
  harvestablePods: BigInt!
  "Number of pods harvested"
  harvestedPods: BigInt!
  "Flag for if plot is fully harvested"
  fullyHarvested: Boolean!
}

type PodMarketplace @entity {
  " Contract address of beanstalk "
  id: ID!
  "Current season of the marketplace"
  season: Int!
  "Indexes of actively listed plots"
  listingIndexes: [BigInt!]!
  "Active pod order IDs"
  orders: [PodOrder!]!
  "All historical listings"
  allListings: [PodListing!]! @derivedFrom(field: "podMarketplace")
  "All historical orders"
  allOrders: [PodOrder!]! @derivedFrom(field: "podMarketplace")
  "All historical marketplace fills"
  fills: [PodFill!]! @derivedFrom(field: "podMarketplace")
  "Current cumulative pods listed for sale"
  listedPods: BigInt!
  "Current cumulative pod listings filled"
  filledListedPods: BigInt!
  "Current cumulative pod listings that expired"
  expiredListedPods: BigInt!
  "Current cumulative pod listings that were cancelled"
  cancelledListedPods: BigInt!
  "Current amount of total pods listed"
  availableListedPods: BigInt!
  "Current cumulative pod orders created"
  orderedPods: BigInt!
  "Current cumulative pod orders filled"
  filledOrderedPods: BigInt!
  "Current cumulative pod orders cancelled"
  cancelledOrderedPods: BigInt!
  "Cumulative pod volume between listings and orders"
  podVolume: BigInt!
  "Cumulative bean volume between listings and orders"
  beanVolume: BigInt!
  "Link to hourly snapshot data"
  hourlySnapshots: [PodMarketplaceHourlySnapshot!]! @derivedFrom(field: "podMarketplace")
  "Link to daily snapshot data"
  dailySnapshots: [PodMarketplaceDailySnapshot!]! @derivedFrom(field: "podMarketplace")
}

type PodMarketplaceHourlySnapshot @entity {
  "Marketplace ID - Unix Timestamp"
  id: ID!
  "Point in time latest season"
  season: Int!
  "Marketplace associated with snapshot"
  podMarketplace: PodMarketplace!
  "Point in time current cumulative pods listed for sale"
  listedPods: BigInt!
  "Point in time current cumulative pod listings filled"
  filledListedPods: BigInt!
  "Point in time current cumulative pod listings that expired"
  expiredListedPods: BigInt!
  "Point in time current cumulative pod listings that were cancelled"
  cancelledListedPods: BigInt!
  "Point in time current amount of total pods listed"
  availableListedPods: BigInt!
  "Point in time current cumulative pod orders created"
  orderedPods: BigInt!
  "Point in time current cumulative pod orders filled"
  filledOrderedPods: BigInt!
  "Point in time current cumulative pod orders cancelled"
  cancelledOrderedPods: BigInt!
  "Point in time current cumulative pod volume between listings and orders"
  podVolume: BigInt!
  "Point in time current cumulative bean volume between listings and orders"
  beanVolume: BigInt!
  "Point in time current delta pods listed for sale"
  deltaListedPods: BigInt!
  "Point in time current delta pod listings filled"
  deltaFilledListedPods: BigInt!
  "Point in time current delta pod listings that expired"
  deltaExpiredListedPods: BigInt!
  "Point in time current delta pod listings that were cancelled"
  deltaCancelledListedPods: BigInt!
  "Point in time current delta of total pods listed"
  deltaAvailableListedPods: BigInt!
  "Point in time current delta pod orders created"
  deltaOrderedPods: BigInt!
  "Point in time current delta pod orders filled"
  deltaFilledOrderedPods: BigInt!
  "Point in time current delta pod orders cancelled"
  deltaCancelledOrderedPods: BigInt!
  "Point in time current delta pod volume between listings and orders"
  deltaPodVolume: BigInt!
  "Point in time current delta bean volume between listings and orders"
  deltaBeanVolume: BigInt!
  "Timestamp of initial snapshot creation"
  createdAt: BigInt!
  "Timestamp of last entity update"
  updatedAt: BigInt!
}

type PodMarketplaceDailySnapshot @entity {
  "Marketplace ID - Unix Timestamp"
  id: ID!
  "Point in time latest season"
  season: Int!
  "Marketplace associated with snapshot"
  podMarketplace: PodMarketplace!
  "Point in time current cumulative pods listed for sale"
  listedPods: BigInt!
  "Point in time current cumulative pod listings filled"
  filledListedPods: BigInt!
  "Point in time current cumulative pod listings that expired"
  expiredListedPods: BigInt!
  "Point in time current cumulative pod listings that were cancelled"
  cancelledListedPods: BigInt!
  "Point in time current amount of total pods listed"
  availableListedPods: BigInt!
  "Point in time current cumulative pod orders created"
  orderedPods: BigInt!
  "Point in time current cumulative pod orders filled"
  filledOrderedPods: BigInt!
  "Point in time current cumulative pod orders cancelled"
  cancelledOrderedPods: BigInt!
  "Point in time current cumulative pod volume between listings and orders"
  podVolume: BigInt!
  "Point in time current cumulative bean volume between listings and orders"
  beanVolume: BigInt!
  "Point in time current delta pods listed for sale"
  deltaListedPods: BigInt!
  "Point in time current delta pod listings filled"
  deltaFilledListedPods: BigInt!
  "Point in time current delta pod listings that expired"
  deltaExpiredListedPods: BigInt!
  "Point in time current delta pod listings that were cancelled"
  deltaCancelledListedPods: BigInt!
  "Point in time current delta of total pods listed"
  deltaAvailableListedPods: BigInt!
  "Point in time current delta pod orders created"
  deltaOrderedPods: BigInt!
  "Point in time current delta pod orders filled"
  deltaFilledOrderedPods: BigInt!
  "Point in time current delta pod orders cancelled"
  deltaCancelledOrderedPods: BigInt!
  "Point in time current delta pod volume between listings and orders"
  deltaPodVolume: BigInt!
  "Point in time current delta bean volume between listings and orders"
  deltaBeanVolume: BigInt!
  "Timestamp of initial snapshot creation"
  createdAt: BigInt!
  "Timestamp of last entity update"
  updatedAt: BigInt!
}

type PodListing @entity {
  "Account - Plot Index"
  id: ID!
  "Marketplace used for listing"
  podMarketplace: PodMarketplace!
  " Historical ID for joins on frontend"
  historyID: String!
  "Plot being listed"
  plot: Plot!
  "Farmer listing the plot"
  farmer: Farmer!
  "Timestamp created"
  createdAt: BigInt!
  "Timestamp updated"
  updatedAt: BigInt!
  "Current market status of listing"
  status: MarketStatus!
  "Any associated market fill"
  fill: PodFill
  "Original index of the plot listed"
  originalIndex: BigInt!
  "Current index of plot listed"
  index: BigInt!
  "Start within plot for listing"
  start: BigInt!
  "Amount of pods listed"
  amount: BigInt!
  "Total amount of original listing"
  originalAmount: BigInt!
  "Remaining amount left to be filled"
  remainingAmount: BigInt!
  "Amount filled on this listing"
  filledAmount: BigInt!
  "Total amount filled from original listing"
  filled: BigInt!
  "Amount cancelled"
  cancelledAmount: BigInt!
  "Market v1 price per pod"
  pricePerPod: Int!
  "Minimum amount needed to fill this listing"
  minFillAmount: BigInt!
  "Max harvestable index before listing expires"
  maxHarvestableIndex: BigInt!
  "Market v2 pricing function"
  pricingFunction:Bytes
  "Sale bean mode (internal/external)"
  mode: Int!
  "Market v2 pricing type"
  pricingType: Int
}

type PodOrder @entity {
  "Order ID emitted by event"
  id: ID!
  "Marketplace used for order"
  podMarketplace: PodMarketplace!
  " Historical ID for joins"
  historyID: String!
  "Farmer placing the order"
  farmer: Farmer!
  "Creation timestamp"
  createdAt: BigInt!
  "Timestamp updated"
  updatedAt: BigInt!
  "Current status of order"
  status: MarketStatus!
  "Any fill associated with this order"
  fill: PodFill
  "V1 - Original amount of the ordered pods"
  podAmount: BigInt!
  "V2 - Original amount of beans used to order pods"
  beanAmount: BigInt!
  "Current filled amount"
  podAmountFilled: BigInt!
  "Bean Amount Filled"
  beanAmountFilled: BigInt!
  "Minimum amount needed to fill this order"
  minFillAmount: BigInt!
  "Max place in line for pods to fulfill the order"
  maxPlaceInLine: BigInt!
  "Market v1 price per pod"
  pricePerPod: Int!
  "Market v2 pricing function"
  pricingFunction: Bytes
  "Market v2 pricing type"
  pricingType: Int
}

type PodFill @entity {
  "Beanstalk address - Order/Listing index - transaction hash"
  id: ID!
  "Marketplace associated with this fill"
  podMarketplace: PodMarketplace!
  "Creation timestamp"
  createdAt: BigInt!
  "Associated listing, if any"
  listing: PodListing
  "Associated order, if any"
  order: PodOrder
  "Account fulfilling the order"
  from: String!      # These are already referenced via the listing and order entities.
  "Account filling the order"
  to: Farmer!
  "Number of pods filled"
  amount: BigInt!
  "Index of plot transferred"
  index: BigInt!
  "Start of plot transferred"
  start: BigInt!
  "Total beans used to fill listing/order"
  costInBeans: BigInt
}

##################################
##### Fertilizer Entities #####
##################################

# Global Fertilizer state for tracking
type Fertilizer @entity {
  "Token address for fert"
  id: ID!
  "Total overall suppy of fert tokens"
  supply: BigInt!
  tokens: [FertilizerToken!]! @derivedFrom(field: "fertilizer")
}

# Id-level Fertilizer entity
type FertilizerToken @entity {
  "Total BPF for purchase"
  id: ID!
  fertilizer: Fertilizer!
  "Total supply for this Humidity"
  supply: BigInt!
  "Humidity paid for this ID"
  humidity: BigDecimal!
  "Ending BPF on creation"
  endBpf: BigInt!
  "Starting BPF on creation"
  startBpf: BigInt!
  "Season created"
  season: Int!
  balances: [FertilizerBalance!]! @derivedFrom(field: "fertilizerToken")
}

# 
type FertilizerBalance @entity {
  "Fertilizer Token - Farmer address"
  id: ID!
  fertilizerToken: FertilizerToken!
  farmer: Farmer!
  "Current balance of token"
  amount: BigInt!
}

##################################
##### Event-Level Data #####
##################################

### We need to add these in

"""
An event is any user action that occurs in a protocol. Generally, they are Ethereum events
emitted by a function in the smart contracts, stored in transaction receipts as event logs.
However, some user actions of interest are function calls that don't emit events. For example,
the deposit and withdraw functions in Yearn do not emit any events. In our subgraphs, we still
store them as events, although they are not technically Ethereum events emitted by smart
contracts.
"""

interface SiloEvent {
  " { Event type }-{ Transaction hash }-{ Log index } "
  id: ID!
  " Transaction hash of the transaction that emitted this event "
  hash: String!
  " Event log index. For transactions that don't emit event, create arbitrary index starting from 0 "
  logIndex: Int!
  " The protocol this transaction belongs to "
  protocol: Beanstalk!
  " Block number of this event "
  blockNumber: BigInt!
  " Timestamp of this event "
  createdAt: BigInt!
}

interface FieldEvent {
  " { Event type }-{ Transaction hash }-{ Log index } "
  id: ID!
  " Transaction hash of the transaction that emitted this event "
  hash: String!
  " Event log index. For transactions that don't emit event, create arbitrary index starting from 0 "
  logIndex: Int!
  " The protocol this transaction belongs to "
  protocol: Beanstalk!
  " Block number of this event "
  blockNumber: BigInt!
  " Timestamp of this event "
  createdAt: BigInt!
}

interface MarketplaceEvent {
  " { Event type }-{ Transaction hash }-{ Log index } "
  id: ID!
  " Transaction hash of the transaction that emitted this event "
  hash: String!
  " Event log index. For transactions that don't emit event, create arbitrary index starting from 0 "
  logIndex: Int!
  " The protocol this transaction belongs to "
  protocol: Beanstalk!
  " Block number of this event "
  blockNumber: BigInt!
  " Timestamp of this event "
  createdAt: BigInt!
}

type PodTransfer implements FieldEvent @entity(immutable: true) {
  " podtransfer-{ Transaction hash }-{ Log index } "
  id: ID!
  " Transaction hash of the transaction that emitted this event "
  hash: String!
  " Event log index. For transactions that don't emit event, create arbitrary index starting from 0 "
  logIndex: Int!
  " The protocol this transaction belongs to "
  protocol: Beanstalk!
  " Address that received the pods "
  to: String!
  " Address that sent the pods "
  from: String!
  " Index of the pods sent"
  index: BigInt!
  " Total pods being sent"
  pods: BigInt!
  " Block number of this event "
  blockNumber: BigInt!
  " Timestamp of this event "
  createdAt: BigInt!
}

type Harvest implements FieldEvent @entity(immutable: true) {
  "harvest-{ Transaction hash }-{ Log index } "
  id: ID!
  " Transaction hash of the transaction that emitted this event "
  hash: String!
  " Event log index. For transactions that don't emit event, create arbitrary index starting from 0 "
  logIndex: Int!
  " The protocol this transaction belongs to "
  protocol: Beanstalk!
  " Address harvesting beans "
  farmer: String!
  " Plots being harvested "
  plots: [BigInt!]!
  " Total beans harvested "
  beans: BigInt!
  " Block number of this event "
  blockNumber: BigInt!
  " Timestamp of this event "
  createdAt: BigInt!
  
}

type Chop implements SiloEvent @entity(immutable: true){
  "chop-{ Transaction hash }-{ Log index }"
  id: ID!
  " Transaction hash of the transaction that emitted this event "
  hash: String!
  " Event log index. For transactions that don't emit event, create arbitrary index starting from 0 "
  logIndex: Int!
  " The protocol this transaction belongs to "
  protocol: Beanstalk!
  " Address chopping "
  farmer: String!
  " Unripe token being chopped "
  unripe: String!
  " Amount being chopped"
  amount: BigInt!
  " Underlying token "
  underlying: String!
  " Block number of this event "
  blockNumber: BigInt!
  " Timestamp of this event "
  createdAt: BigInt!
}

type Incentive implements SiloEvent @entity(immutable: true) {
  "incentive-{ Transaction hash }-{ Log index }"
  id: ID!
  " Transaction hash of the transaction that emitted this event "
  hash: String!
  " Event log index. For transactions that don't emit event, create arbitrary index starting from 0 "
  logIndex: Int!
  " The protocol this transaction belongs to "
  protocol: Beanstalk!
  " Address incentivized "
  caller: String!
  " Amount minted as incentive"
  amount: BigInt!
  " Block number of this event "
  blockNumber: BigInt!
  " Timestamp of this event "
  createdAt: BigInt!
}

type Reward implements SiloEvent @entity(immutable: true) {
  "reward-{ Transaction hash }-{ Log index }"
  id: ID!
  " Transaction hash of the transaction that emitted this event "
  hash: String!
  " Event log index. For transactions that don't emit event, create arbitrary index starting from 0 "
  logIndex: Int!
  " The protocol this transaction belongs to "
  protocol: Beanstalk!
  " Season of reward "
  season: Int!
  " Amount minted to pod line"
  toField: BigInt!
  " Amount minted to silo"
  toSilo: BigInt!
  " Amount minted to fertilizer"
  toFertilizer: BigInt!
  " Block number of this event "
  blockNumber: BigInt!
  " Timestamp of this event "
  createdAt: BigInt!
}

type MetapoolOracle implements SiloEvent @entity(immutable: true) {
  "metapoolOracle-{ Transaction hash }-{ Log index }"
  id: ID!
  " Transaction hash of the transaction that emitted this event "
  hash: String!
  " Event log index. For transactions that don't emit event, create arbitrary index starting from 0 "
  logIndex: Int!
  " The protocol this transaction belongs to "
  protocol: Beanstalk!
  " Season of oracle "
  season: Int!
  " DeltaB for season"
  deltaB: BigInt!
  " Cumulative balance A"
  balanceA: BigInt!
  " Cumulative balance B"
  balanceB: BigInt!
  " Block number of this event "
  blockNumber: BigInt!
  " Timestamp of this event "
  createdAt: BigInt!
}

type AddDeposit implements SiloEvent @entity(immutable: true) {
  "addDeposit-{ Transaction hash }-{ Log index }"
  id: ID!
  " Transaction hash of the transaction that emitted this event "
  hash: String!
  " Event log index. For transactions that don't emit event, create arbitrary index starting from 0 "
  logIndex: Int!
  " The protocol this transaction belongs to "
  protocol: Beanstalk!
  " Account removing deposit"
  account: String!
  " Token removed"
  token: String!
  " Season of deposit removed "
  season: Int!
  " Amount of token removed "
  amount: BigInt!
  " BDV of the deposit "
  bdv: BigInt!
  " Block number of this event "
  blockNumber: BigInt!
  " Timestamp of this event "
  createdAt: BigInt!
}

type RemoveDeposit implements SiloEvent @entity(immutable: true) {
  "removeDeposit-{ Transaction hash }-{ Log index }"
  id: ID!
  " Transaction hash of the transaction that emitted this event "
  hash: String!
  " Event log index. For transactions that don't emit event, create arbitrary index starting from 0 "
  logIndex: Int!
  " The protocol this transaction belongs to "
  protocol: Beanstalk!
  " Account removing deposit"
  account: String!
  " Token removed"
  token: String!
  " Season of deposit removed "
  season: Int!
  " Amount of token removed "
  amount: BigInt!
  " Block number of this event "
  blockNumber: BigInt!
  " Timestamp of this event "
  createdAt: BigInt!
}

type StalkChange implements SiloEvent @entity(immutable: true) {
  "stalkChange-{ Transaction hash }-{ Log index }"
  id: ID!
  " Transaction hash of the transaction that emitted this event "
  hash: String!
  " Event log index. For transactions that don't emit event, create arbitrary index starting from 0 "
  logIndex: Int!
  " The protocol this transaction belongs to "
  protocol: Beanstalk!
  " Account removing deposit"
  account: String!
  " Token removed"
  delta: BigInt!
  " Season when the change happened "
  season: Int!
  " Block number of this event "
  blockNumber: BigInt!
  " Timestamp of this event "
  createdAt: BigInt!
}

type SeedChange implements SiloEvent @entity(immutable: true) {
  "seedChange-{ Transaction hash }-{ Log index }"
  id: ID!
  " Transaction hash of the transaction that emitted this event "
  hash: String!
  " Event log index. For transactions that don't emit event, create arbitrary index starting from 0 "
  logIndex: Int!
  " The protocol this transaction belongs to "
  protocol: Beanstalk!
  " Account removing deposit"
  account: String!
  " Token removed"
  delta: BigInt!
  " Season when the change happened "
  season: Int!
  " Block number of this event "
  blockNumber: BigInt!
  " Timestamp of this event "
  createdAt: BigInt!
}

type PodListingCreated implements MarketplaceEvent @entity(immutable: true) {
  "podListingCreated-{ Transaction hash }-{ Log index }"
  id: ID!
  " Transaction hash of the transaction that emitted this event "
  hash: String!
  " Event log index. For transactions that don't emit event, create arbitrary index starting from 0 "
  logIndex: Int!
  " The protocol this transaction belongs to "
  protocol: Beanstalk!
  " Historical ID for joins"
  historyID: String!
  " Account creating the listing"
  account: String!
  " Index of the plot listed"
  index: BigInt!
  " Start value of the plot listed "
  start: BigInt!
  "Amount of pods listed"
  amount: BigInt!
  "Price per pod"
  pricePerPod: Int!
  "Max index for listing"
  maxHarvestableIndex: BigInt!
  "Claim to location"
  mode: Int!
  "Pricing Function Data"
  pricingFunction: Bytes
  "Pricing Type"
  pricingType: Int
  " Block number of this event "
  blockNumber: BigInt!
  " Timestamp of this event "
  createdAt: BigInt!
}

type PodListingFilled implements MarketplaceEvent @entity(immutable: true) {
  "podListingFilled-{ Transaction hash }-{ Log index }"
  id: ID!
  " Transaction hash of the transaction that emitted this event "
  hash: String!
  " Event log index. For transactions that don't emit event, create arbitrary index starting from 0 "
  logIndex: Int!
  " The protocol this transaction belongs to "
  protocol: Beanstalk!
  " Historical ID for joins"
  historyID: String!
  "Account selling pods"
  from: String!
  "Account buying pods"
  to: String!
  "Index of the plot transferred"
  index: BigInt!
  "Start of the plot transferred"
  start: BigInt!
  "Number of pods transferred"
  amount: BigInt!
  "Beans paid to fill the listing"
  costInBeans: BigInt
  " Block number of this event "
  blockNumber: BigInt!
  " Timestamp of this event "
  createdAt: BigInt!
}

type PodListingCancelled implements MarketplaceEvent @entity(immutable: true) {
  "seedChange-{ Transaction hash }-{ Log index }"
  id: ID!
  " Transaction hash of the transaction that emitted this event "
  hash: String!
  " Event log index. For transactions that don't emit event, create arbitrary index starting from 0 "
  logIndex: Int!
  " The protocol this transaction belongs to "
  protocol: Beanstalk!
  " Historical ID for joins"
  historyID: String!
  " Account cancelling listing"
  account: String!
  " Index of plot listing being cancelled"
  index: BigInt!
  " Block number of this event "
  blockNumber: BigInt!
  " Timestamp of this event "
  createdAt: BigInt!
}

type PodOrderCreated implements MarketplaceEvent @entity(immutable: true) {
  "podOrderCreated-{ Transaction hash }-{ Log index }"
  id: ID!
  " Transaction hash of the transaction that emitted this event "
  hash: String!
  " Event log index. For transactions that don't emit event, create arbitrary index starting from 0 "
  logIndex: Int!
  " The protocol this transaction belongs to "
  protocol: Beanstalk!
  " Historical ID for joins"
  historyID: String!
  " Account creating the listing"
  account: String!
  " ID of the pod order"
  orderId: String!
  "Amount of pods listed"
  amount: BigInt!
  "Price per pod"
  pricePerPod: Int!
  "Max place in line"
  maxPlaceInLine: BigInt!
  "Pricing Function Data"
  pricingFunction: Bytes
  "Pricing Type"
  pricingType: Int
  " Block number of this event "
  blockNumber: BigInt!
  " Timestamp of this event "
  createdAt: BigInt!
}

type PodOrderFilled implements MarketplaceEvent @entity(immutable: true) {
  "podOrderFilled-{ Transaction hash }-{ Log index }"
  id: ID!
  " Transaction hash of the transaction that emitted this event "
  hash: String!
  " Event log index. For transactions that don't emit event, create arbitrary index starting from 0 "
  logIndex: Int!
  " The protocol this transaction belongs to "
  protocol: Beanstalk!
  " Historical ID for joins"
  historyID: String!
  "Account selling pods"
  from: String!
  "Account buying pods"
  to: String!
  "Index of the plot transferred"
  index: BigInt!
  "Start of the plot transferred"
  start: BigInt!
  "Number of pods transferred"
  amount: BigInt!
  "Beans paid to fill the order"
  costInBeans: BigInt
  " Block number of this event "
  blockNumber: BigInt!
  " Timestamp of this event "
  createdAt: BigInt!
}

type PodOrderCancelled implements MarketplaceEvent @entity(immutable: true) {
  "podOrderCancelled-{ Transaction hash }-{ Log index }"
  id: ID!
  " Transaction hash of the transaction that emitted this event "
  hash: String!
  " Event log index. For transactions that don't emit event, create arbitrary index starting from 0 "
  logIndex: Int!
  " The protocol this transaction belongs to "
  protocol: Beanstalk!
  " Historical ID for joins"
  historyID: String!
  " Account cancelling listing"
  account: String!
  " ID of order cancelled"
  orderId: String!
  " Block number of this event "
  blockNumber: BigInt!
  " Timestamp of this event "
  createdAt: BigInt!
}

type WhitelistToken implements SiloEvent @entity(immutable: true) {
  "whitelistToken-{ Transaction hash }-{ Log index }"
  id: ID!
  " Transaction hash of the transaction that emitted this event "
  hash: String!
  " Event log index. For transactions that don't emit event, create arbitrary index starting from 0 "
  logIndex: Int!
  " The protocol this transaction belongs to "
  protocol: Beanstalk!
  "Token address whitelisted"
  token: String!
  "Stalk per BDV"
  stalk: BigInt!
  "Seeds per BDV"
  seeds: BigInt!
  "Selector for token"
  selector: String!
  " Block number of this event "
  blockNumber: BigInt!
  " Timestamp of this event "
  createdAt: BigInt!
}

type DewhitelistToken implements SiloEvent @entity(immutable: true) {
  "dewhitelistToken-{ Transaction hash }-{ Log index }"
  id: ID!
  " Transaction hash of the transaction that emitted this event "
  hash: String!
  " Event log index. For transactions that don't emit event, create arbitrary index starting from 0 "
  logIndex: Int!
  " The protocol this transaction belongs to "
  protocol: Beanstalk!
  "Token address dewhitelisted"
  token: String!
  " Block number of this event "
  blockNumber: BigInt!
  " Timestamp of this event "
  createdAt: BigInt!
}
